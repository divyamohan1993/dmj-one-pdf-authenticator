# dmj-fetcher.sh
# POSIX sh (no Bash-isms)
dmj_fetch_fresh() {    
    # Usage: dmj_fetch_fresh URL DEST [flags...]
    # dmj_fetch_fresh "url" "des/ti/na.tion" -chmod 0755 -chown "dmjsvc:dmjsvc" -hash "sha256:7f9c...c0a" -replacevars true
    # Flags (optional; can be used instead of positionals):
    #   -chmod OCTAL         set permissions (e.g. 0755)
    #   -chown USER[:GROUP]  set ownership on the final file
    #   -hash  SHA256        expected SHA-256 (hex, or 'sha256:<hex>')
    #   -replacevars [bool]  expand ${VAR}/$VAR from current shell/env (default: false)
    #
    # Environment variables (optional):
    #   DMJ_FETCH_CURL            path to curl (default: curl)
    #   DMJ_FETCH_CONNECT_TIMEOUT seconds (default: 10)
    #   DMJ_FETCH_MAX_TIME        seconds (default: 900)
    #   DMJ_FETCH_RETRIES         retry count (default: 5)
    #   DMJ_FETCH_HSTS_FILE       HSTS cache file (default: $HOME/.cache/dmj_fetch_hsts)
    #   DMJ_FETCH_INSECURE        set 1 to allow http / weak TLS (default: 0 = enforced HTTPS + HSTS)
    #   DMJ_FETCH_AUTH_HEADER     e.g. "Authorization: Bearer TOKEN" (optional)
    #   DMJ_FETCH_ALLOWED_HOSTS   comma-separated allowlist of hostnames (optional)

    # No global set/pipefail/traps here — do those in a subshell to avoid
    # side-effects on callers running strict mode.

    if [ "$#" -lt 2 ]; then
        printf '%s\n' "usage: dmj_fetch_fresh URL DEST [PERM] [SHA256] [-chmod OCTAL] [-chown USER[:GROUP]] [-hash SHA256] [-replacevars [true|false]]" >&2
        return 64
    fi

    url=$1
    dest=$2
    shift 2

    # Defaults (positional back-compat + flags)
    perm=""
    expected=""
    owner=""
    do_replace=0

    # Legacy positionals [PERM] [SHA256] if present and not flags
    case "${1-}" in -*) ;; "" ) ;; * ) perm=$1; shift ;; esac
    case "${1-}" in -*) ;; "" ) ;; * ) expected=$1; shift ;; esac

    # Flag parser (POSIX)
    while [ "$#" -gt 0 ]; do
        case "$1" in
            -chmod)
                [ "$#" -ge 2 ] || { printf '%s\n' "error: -chmod requires an argument" >&2; return 64; }
                perm=$2; shift 2 ;;
            -chown)
                [ "$#" -ge 2 ] || { printf '%s\n' "error: -chown requires an argument" >&2; return 64; }
                owner=$2; shift 2 ;;
            -hash)
                [ "$#" -ge 2 ] || { printf '%s\n' "error: -hash requires an argument" >&2; return 64; }
                expected=$2; shift 2 ;;
            -replacevars)
                do_replace=1
                case "${2-}" in
                    true|1|yes|on)  do_replace=1; shift 2 ;;
                    false|0|no|off) do_replace=0; shift 2 ;;
                    -*)             shift 1 ;;    # next flag
                    "" )            shift 1 ;;    # bare toggle
                    *  )            shift 1 ;;    # ignore non-boolean
                esac ;;
            --) shift; break ;;
            -*) printf '%s\n' "error: unknown flag '$1'" >&2; return 64 ;;
            *)  printf '%s\n' "error: unexpected argument '$1'" >&2; return 64 ;;
        esac
    done

    # Validate permission (octal)
    if [ -n "$perm" ]; then
        case "$perm" in
            [0-7][0-7][0-7]|[0-7][0-7][0-7][0-7]) : ;;
            *) printf '%s\n' "error: PERM must be octal like 0644 or 0755" >&2; return 64 ;;
        esac
    fi

    # Normalize expected checksum (allow "sha256:<hex>")
    if [ -n "$expected" ]; then
        case "$expected" in sha256:*) expected=${expected#sha256:} ;; esac
        expected=$(printf '%s' "$expected" | tr 'A-F' 'a-f')
        case "$expected" in [0-9a-f][0-9a-f]*) : ;; *) printf '%s\n' "error: SHA256 must be hex" >&2; return 64 ;; esac
    fi

    # Optional host allowlist
    if [ -n "${DMJ_FETCH_ALLOWED_HOSTS-}" ]; then
        host=$(printf '%s' "$url" | sed -n 's,^[a-zA-Z][a-zA-Z0-9+.-]*://,,; s,/.*$,,; s,:.*$,,; p')
        allowed=0; oldIFS=$IFS; IFS=,
        for h in $DMJ_FETCH_ALLOWED_HOSTS; do [ "$host" = "$h" ] && { allowed=1; break; }; done
        IFS=$oldIFS
        [ $allowed -eq 1 ] || { printf '%s\n' "error: host '$host' not allowed" >&2; return 65; }
    fi

    # Ensure destination directory
    dir=$(dirname "$dest"); base=$(basename "$dest"); [ -d "$dir" ] || mkdir -p "$dir"

    # Portable mktemp template in same dir (no GNU -p)
    # 077 - 0600 || 022 - 0755
    umask 022
    tmp="${dir%/}/.${base}.tmp.XXXXXXXXXX"
    tmp=$(mktemp "$tmp") || { printf '%s\n' "error: mktemp failed in $dir" >&2; return 70; }

    # Do the risky work in a subshell with strict mode + cleanup trap,
    # so we don't alter caller shell options or traps.
    (
        set -eu
        # pipefail if available
        ( set -o pipefail ) >/dev/null 2>&1 && set -o pipefail || :
        trap 'rm -f "$tmp"' INT TERM HUP EXIT

        # Defaults
        curl_bin=${DMJ_FETCH_CURL-curl}
        : "${DMJ_FETCH_CONNECT_TIMEOUT:=10}"
        : "${DMJ_FETCH_MAX_TIME:=900}"
        : "${DMJ_FETCH_RETRIES:=5}"
        : "${DMJ_FETCH_INSECURE:=0}"
        : "${DMJ_FETCH_HSTS_FILE:=$HOME/.cache/dmj_fetch_hsts}"

        # Build argv for curl using "set --" (POSIX-safe)
        set -- "$curl_bin" \
            --fail --location \
            --connect-timeout "$DMJ_FETCH_CONNECT_TIMEOUT" \
            --max-time "$DMJ_FETCH_MAX_TIME" \
            --retry "$DMJ_FETCH_RETRIES" --retry-connrefused

        # Add retry-all-errors if supported by the installed curl (≥7.71.0)
        if "$curl_bin" --help all 2>/dev/null | grep -q -- "--retry-all-errors"; then
            set -- "$@" --retry-all-errors
        fi

        # Progress behavior; gate --no-progress-meter (≥7.67.0)
        if "$curl_bin" --help all 2>/dev/null | grep -q -- "--no-progress-meter"; then
            if [ -t 2 ]; then set -- "$@" --progress-bar; else set -- "$@" --no-progress-meter; fi
        else
            set -- "$@" -sS
        fi

        # Bypass caches & avoid content-encoding transformations
        set -- "$@" \
            -H "Cache-Control: no-cache, no-store" \
            -H "Pragma: no-cache" \
            -H "Expires: 0" \
            -H "Accept-Encoding: identity"

        # Optional Authorization (or any single custom header)
        [ -n "${DMJ_FETCH_AUTH_HEADER-}" ] && set -- "$@" -H "$DMJ_FETCH_AUTH_HEADER"

        # Enforce HTTPS; gate --hsts (≥7.74.0)
        if [ "$DMJ_FETCH_INSECURE" -eq 0 ]; then
            set -- "$@" --proto "=https" --proto-redir "=https" --tlsv1.2
            if "$curl_bin" --help all 2>/dev/null | grep -q -- "--hsts"; then
                set -- "$@" --hsts "$DMJ_FETCH_HSTS_FILE"
            fi
        fi

        # Output & URL
        set -- "$@" --output "$tmp" --url "$url"

        # Execute curl
        "$@"

        # Optional checksum verification
        if [ -n "$expected" ]; then
            if command -v sha256sum >/dev/null 2>&1; then
                got=$(sha256sum "$tmp" | awk '{print $1}')
            elif command -v shasum >/dev/null 2>&1; then
                got=$(shasum -a 256 "$tmp" | awk '{print $1}')
            elif command -v openssl >/dev/null 2>&1; then
                got=$(openssl dgst -sha256 "$tmp" | awk '{print $NF}' | tr 'A-F' 'a-f')
            else
                printf '%s\n' "error: no SHA-256 tool (sha256sum|shasum|openssl)" >&2; exit 69
            fi
            [ "$got" = "$expected" ] || {
                printf '%s\n' "error: checksum mismatch for %s" "$dest" >&2
                printf '  expected: %s\n' "$expected" >&2
                printf '  got:      %s\n' "$got" >&2
                exit 60
            }
        fi

        # Optional variable replacement (only when -replacevars was requested)
        if [ "${do_replace:-0}" -eq 1 ]; then
            esc_marker="__DMJ_ESC_DOLLAR__"
            tmp_esc="${tmp}.esc"
            tmp_vars="${tmp}.vars"
            tmp_proc="${tmp}.proc"

            # 1) Protect escaped dollars so they are never substituted
            #    e.g., \$host, \${dir} -> keep as literals
            sed 's/\\\$/__DMJ_ESC_DOLLAR__/g' "$tmp" > "$tmp_esc" || exit 72

            # 2) Discover candidate names (${VAR}, ${VAR:-...}, $VAR) from unescaped dollars
            awk '
                {
                    s=$0
                    while (match(s, /\$\{[A-Za-z_][A-Za-z0-9_]*(:-[^}]*)?\}|\$[A-Za-z_][A-Za-z0-9_]*/)) {
                        tok=substr(s,RSTART,RLENGTH)
                        if (substr(tok,2,1)=="{") {
                            n=tok
                            sub(/^\$\{/, "", n); sub(/\}$/, "", n)
                            d=index(n,":-"); if (d>0) name=substr(n,1,d-1); else name=n
                        } else {
                            name=substr(tok,2)
                        }
                        print name
                        s=substr(s,RSTART+RLENGTH)
                    }
                }
            ' "$tmp_esc" | sort -u > "$tmp_vars"

            # 3) Export only the variables that actually exist in *this* shell
            #    (so awk can read them via ENVIRON[]). Unknown placeholders stay untouched.
            varnames=""
            if [ -s "$tmp_vars" ]; then
                while IFS= read -r vname; do
                    case "$vname" in
                        ''|*[!A-Za-z0-9_]*|[0-9]* ) continue ;;
                    esac
                    eval 'present=${'"$vname"'+x}'
                    if [ -n "${present-}" ]; then
                        eval "export $vname"
                        varnames="$varnames $vname"
                    fi
                done < "$tmp_vars"
            fi

             # 4) Smart substitution (order-aware):
            #    - Replace until a variable gets assigned in the file; skip afterwards.
            #    - Do NOT replace a variable on its own assignment line
            #      (e.g., keep TESTVAR="${TESTVAR:-default}").
            awk -v HAVEVARS="$varnames" '
                BEGIN {
                    n=split(HAVEVARS, L, /[ \t]+/)
                    for (i=1;i<=n;i++) if (L[i]!="") allowed[L[i]]=1
                }
                # Return VAR name if line is a simple assignment at start of line:
                #   [export|readonly|local|typeset|declare] [-flags] VAR=...
                function lhs_assign(line,   name) {
                    # strip leading ws
                    sub(/^[ \t]+/, "", line)
                    # drop leading keywords+optional flags repeatedly
                    while (match(line, /^(export|readonly|local|typeset|declare)([ \t]+-[^ \t]+)*/)) {
                        line = substr(line, RSTART + RLENGTH)
                        sub(/^[ \t]+/, "", line)
                    }
                    # now expect VAR[ ws]*=
                    if (match(line, /^[A-Za-z_][A-Za-z0-9_]*[ \t]*=/)) {
                        name = substr(line, RSTART, RLENGTH)
                        sub(/[ \t]*=.*/, "", name)
                        return name
                    }
                    return ""
                }
                {
                    ln=$0
                    LH=lhs_assign(ln)
                    out=""; rest=ln
                    while (match(rest, /\$\{[A-Za-z_][A-Za-z0-9_]*(:-[^}]*)?\}|\$[A-Za-z_][A-Za-z0-9_]*/)) {
                        pre = substr(rest,1,RSTART-1)
                        tok = substr(rest,RSTART,RLENGTH)
                        name=""; hasdef=0
                        if (substr(tok,2,1)=="{") {
                            n = tok
                            sub(/^\$\{/, "", n); sub(/\}$/, "", n)
                            d = index(n,":-")
                            if (d>0) { name = substr(n,1,d-1); hasdef=1 } else { name=n }
                        } else {
                            name = substr(tok,2)
                        }
                        repl = tok
                         if (name in allowed) {
                            envv = ENVIRON[name]
                            if (!(name in assigned) && name != LH) {
                            # Skip after first assignment; also skip replacing the LHS var on its own line
                                if (hasdef) {
                                    if (envv != "") repl = envv
                                } else {
                                    repl = envv
                                }
                            }
                        }
                        out = out pre repl
                        rest = substr(rest, RSTART+RLENGTH)
                    }
                    out = out rest
                    print out
                    if (LH!="") assigned[LH]=1
                }
            ' "$tmp_esc" > "$tmp_proc" || exit 77

            # 5) Restore escaped dollars and write back
            # sed 's/__DMJ_ESC_DOLLAR__/\\$/g' "$tmp_proc" > "$tmp" || exit 76
            sed 's/__DMJ_ESC_DOLLAR__/$/g' "$tmp_proc" > "$tmp" || exit 76
            rm -f "$tmp_esc" "$tmp_proc" "$tmp_vars" 2>/dev/null || :
        fi

        # Normalize UTF‑8 BOM and CRLF → LF for *text* payloads.
        # Prefer file(1) when present; otherwise fall back to extension heuristics.
        is_text=0
        if command -v file >/dev/null 2>&1; then
            if file "$tmp" 2>/dev/null | grep -qi 'text'; then is_text=1; fi
        else
            case "$dest" in
                *.sh|*.env|*.txt|*.conf|*.cfg|*.json|*.yaml|*.yml|*.toml|*.service|*.unit|*.properties|*.ini|*.tmpl) is_text=1;;
            esac
        fi
        if [ "$is_text" -eq 1 ]; then
            tmp_clean="${tmp}.clean"
            # Portable cleanup using awk: drop BOM on first line and CR at end-of-line.
            awk 'NR==1{sub(/^\xef\xbb\xbf/,"")} {sub(/\r$/,"")} 1' "$tmp" >"$tmp_clean" && mv "$tmp_clean" "$tmp"
        fi      

        # Apply permission (set it on temp, then atomic rename)
        [ -n "$perm" ] && chmod "$perm" "$tmp"

        # Atomic install (rename on same FS; otherwise cp+rm)
        if mv -f "$tmp" "$dest" 2>/dev/null; then :; else
            cp "$tmp" "$dest" && rm -f "$tmp" || { printf '%s\n' "error: could not install $dest" >&2; exit 71; }
        fi

        # Optional ownership
        if [ -n "${owner-}" ]; then
            if ! chown "$owner" "$dest"; then
                printf '%s\n' "error: failed to chown $dest to $owner" >&2
                exit 72
            fi
        fi

        trap - INT TERM HUP EXIT
    )
    return 0
}





#-------------- URL to File downloader ---------------------------
# This is how to call it in script
# Use case: dmj_fetch_fresh "url" "des/ti/na.tion" -chmod 0755 -chown "dmjsvc:dmjsvc" -hash "sha256:7f9c...c0a" -replacevars true
# generate the hash after updations: curl -fsSL "https://raw.githubusercontent.com/divyamohan1993/dmj-one-pdf-authenticator/refs/heads/main/one-click-deployment/static/bin/dmj-fetcher.sh" | sha256sum
# DMJ_FETCHER_URL="https://raw.githubusercontent.com/divyamohan1993/dmj-one-pdf-authenticator/refs/heads/main/one-click-deployment/static/bin/dmj-fetcher.sh"
# DMJ_FETCHER_URL_HASH="sha256:daff69838b476a95e43d23fef1acd40b2c30d2a78a8ad98b1a7ca348be2af62a"
# t="$(mktemp -t dmj_fetcher.XXXXXXXX)" || { echo "mktemp failed" >&2; exit 70; }
# trap 'rm -f "$t" "$t.n"' EXIT
# e(){ m="[dmj-fetcher] $*"; command -v systemd-cat >/dev/null && systemd-cat --identifier=dmj-fetcher --priority=err <<<"$m" || logger -t dmj-fetcher -p user.err "$m" 2>/dev/null || echo "$m" >&2; }
# C=(curl -fsSL --retry 6 --proto '=https' --tlsv1.2 -H 'Cache-Control: no-cache, no-store, must-revalidate'); curl --help all 2>/dev/null | grep -q -- '--retry-all-errors' && C+=('--retry-all-errors')
# "${C[@]}" -o "$t" "${DMJ_FETCHER_URL}?_=$(date +%s)" || { e "download failed for $DMJ_FETCHER_URL"; exit 66; }
# exp="${DMJ_FETCHER_URL_HASH#sha256:}"; exp="$(printf %s "$exp" | tr -d '[:space:]' | tr A-F a-f)"; printf %s "$exp" | grep -Eq '^[0-9a-f]{64}$' || { e "DMJ_FETCHER_URL_HASH must be 64-hex SHA-256"; exit 68; }
# if command -v sha256sum >/dev/null; then act="$(sha256sum "$t" | awk '{print tolower($1)}')"
# elif command -v shasum >/dev/null; then act="$(shasum -a 256 "$t" | awk '{print tolower($1)}')"
# elif command -v openssl >/dev/null; then act="$(openssl dgst -sha256 -r "$t" | awk '{print tolower($1)}')"
# else e "no SHA-256 tool found"; exit 69; fi
# [ "$act" = "$exp" ] || { e "authenticity of dmj-fetcher.sh could not be verified and hence no scripts will be downloaded"; exit 67; }
# awk 'NR==1{sub(/^\xef\xbb\xbf/,"")} {sub(/\r$/,"")} 1' "$t" >"$t.n" && mv "$t.n" "$t"
# bash -n "$t" || { e "syntax check failed for $DMJ_FETCHER_URL"; exit 65; }
# . "$t"